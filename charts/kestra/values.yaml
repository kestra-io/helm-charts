nameOverride: ""
fullnameOverride: ""

### -------------------------------
### Image settings
### -------------------------------

# @section -- image settings
image:
  # -- Image repository to use for deploying kestra
  repository: kestra/kestra
  # -- This sets the pull policy for images.
  pullPolicy: IfNotPresent
  # -- Overrides the image tag whose default is the chart appVersion.
  tag: ""
imagePullSecrets: []
# - name: regcred

### -------------------------------
### Common settings
### -------------------------------

# @section -- common settings
common:
  replicas: 1
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  # -- common annotations to be added to all deployments types
  annotations: {}
  # -- common annotations to be added to all pods from deployments types
  podAnnotations: {}
  labels: {}
  podLabels: {}
  livenessProbe:
    httpGet:
      path: /health/liveness
      port: management
    initialDelaySeconds: 0
    periodSeconds: 5
    timeoutSeconds: 3
    successThreshold: 1
    failureThreshold: 3
  readinessProbe:
    httpGet:
      path: /health/readiness
      port: management
    initialDelaySeconds: 0
    periodSeconds: 5
    timeoutSeconds: 3
    successThreshold: 1
    failureThreshold: 3
  startupProbe:
    httpGet:
      path: /health
      port: management
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    successThreshold: 1
    failureThreshold: 120
  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi
  terminationGracePeriodSeconds: 60
  nodeSelector: {}
  tolerations: []
  affinity: {}
  securityContext:
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
  podSecurityContext: {}
    # fsGroup: 2000
  initContainers: []
  extraVolumeMounts: []
  extraVolumes: []
  extraEnv: []
  extraEnvFrom: []
  extraContainers: []

### -------------------------------
### Kestra settings
### -------------------------------

configurations:
  # -- ...
  # @section -- kestra configurations
  application: {}
    # kestra:
    #   queue:
    #     type: h2
    #   repository:
    #     type: h2
    #   storage:
    #     type: local
    #     local:
    #       basePath: "/app/storage"
    # datasources:
    #   h2:
    #     url: jdbc:h2:mem:public;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    #     username: kestra
    #     password: ""
    #     driverClassName: org.h2.Driver
  # -- ...
  # @section -- kestra configurations
  configmaps: []
  # - name: kestra-extra-config
  #   key: storage.yml
  # -- ...
  # @section -- kestra configurations
  secrets: []
  # - name: kestra-extra-secret
  #   key: datasources.yml

### -------------------------------
### kestra service account
### -------------------------------

serviceAccount:
  # -- Specifies whether a service account should be created
  # @section -- serviceAccount
  create: true
  # -- Automatically mount a ServiceAccount's API credentials?
  # @section -- serviceAccount
  automount: true
  # -- Annotations to add to the service account
  # @section -- serviceAccount
  annotations: {}
  # -- The name of the service account to use. If not set and create is true, a name is generated using the fullname template
  # @section -- serviceAccount
  name: ""

### -------------------------------
### kestra deployments
### -------------------------------

deployments:
  standalone:
    # -- Whether to deploy kestra in standalone mode.
    # @section -- kestra deployments
    enabled: true
    # -- By default, we start a number of threads of two times the number of available processors, use 'workerThreads' to configure a different value.
    # @section -- kestra deployments
    workerThreads: 128
  webserver:
    # -- Whether to deploy kestra in distributed mode, webserver will be deployed.
    # @section -- kestra deployments
    enabled: false
  executor:
    # -- Whether to deploy kestra in distributed mode, executor will be deployed.
    # @section -- kestra deployments
    enabled: false
  indexer:
    # -- Whether to deploy kestra in distributed mode, indexer will be deployed.
    # @section -- kestra deployments
    enabled: false
  scheduler:
    # -- Whether to deploy kestra in distributed mode, scheduler will be deployed.
    # @section -- kestra deployments
    enabled: false
  worker:
    # -- Whether to deploy kestra in distributed mode, worker will be deployed.
    # @section -- kestra deployments
    enabled: false
    # -- By default, we start a number of threads of two times the number of available processors, use 'workerThreads' to configure a different value.
    # @section -- kestra deployments
    workerThreads: 128
  # EE only - Define additional group of workers.
  # Must be used in addition to default workers (in standalone or separate worker deployment).
  workerGroups:
    enabled: false
    items: []
      # - name: "my-worker-group"
      #   # By default, we start a number of threads of two times the number of available processors, use 'workerThreads' to configure a different value.
      #   workerThreads: 128

### -------------------------------
### kestra service
### -------------------------------

service:
  type: ClusterIP
  labels: {}
  annotations: {}
  ports:
    http:
      port: 8080
      containerPort: 8080
      targetPort: http
      protocol: TCP
    management:
      port: 8081
      containerPort: 8081
      targetPort: management
      protocol: TCP

### -------------------------------
### kestra dind
### -------------------------------

dind:
  enabled: true
  image:
    repository: docker
    tag: dind-rootless
    pullPolicy: IfNotPresent
  socketPath: /dind/
  tmpPath: /tmp/
  resources: {}
  args:
    - --log-level=fatal
    - --group=1000
  securityContext:
    runAsUser: 1000
    runAsGroup: 1000
  extraVolumeMounts: []
  extraEnv: []

### -------------------------------
### kestra operator
### -------------------------------

# EE only - the Kestra Kubernetes Operator
operator:
  enabled: false
  image: registry.kestra.io/docker/kestra-operator
  apiKey: ""
  basicAuth: ""

### -------------------------------
### Ingress
### -------------------------------

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts: []
    # - host: chart-example.local
    #   paths: []
    #     - path: /
    #       pathType: Prefix
    #       backend:
    #         service:
    #           name: kestra
    #           port:
    #             number: 8080
  tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

### -------------------------------
### Extra Kubernetes Manifests
### -------------------------------

# -- You can specify extra manifests to be deployed with this chart.
extraManifests: []
  # - apiVersion: v1
  #   kind: Secret
  #   metadata:
  #     name: demo
  #   data:
  #     key: {{ .Values.demo.key | b64enc }}
